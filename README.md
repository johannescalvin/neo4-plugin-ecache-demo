# 在Neo4j中使用Ehcahe3做本地缓存
示例: 如何在Neo4j的插件中使用Ehcache做本地缓存

## 缘起

Neo4j Plugin方式，于我个人而言，是使用Neo4j的最可爱的方式。详见博客 [Neo4j的正确用法](http://blog.freecode.tech/yangchengzhu/neo4j/Neo4j%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95.md)。

Neo4j本身的缓存功能是为了优化服务器性能而设计的,对用户来说，是一个黑盒。除了通过配置文件指定通过配置文件中的`dbms.memory.pagecache.size`，以及配置JVM的内存大小，没有办法进行更为精细化的设置。

但应用的缓存需求确实存在, 比如计算逻辑复杂且耗时，但对数据一致性要求不高的场景，计算结果常驻内存带来的收益非常大。如果为了使用Neo4j的自身缓存，那么你需要将计算结果写入Neo4j。这带来的问题非常多：

1. 不可控。数据何时被逐出内存，对程序来说不可控
2. 占用资源。不仅会占用磁盘空间，更为关键的是Neo4j的ID是极为有限的。
3. 对缓存实现过期策略,需要自己实现；而且涉及到磁盘IO，不可能快。
4. 说一千道一万，缓存这种东西，能不能磁盘沾边，就不要沾边。况且，使用Neo4j缓存计算结果，因为和业务数据是混在一起的，必然涉及大量磁盘随机读。
5. 写出来的代码实在是难看，反正我自己回头看都快吐了

本人实战采坑感想： 偷懒只能一时爽，后面遇到问题时会想弄死当时的自己。

## 缓存需求

在Neo4j Plugin中使用缓存时,我的愿望是: 

1. 快速
2. 可监控
3. 实现简单，代码量少
4. 内存使用量可控，或者 扩容方便
5. 支持生命周期管理
6. 尽量不加重Neo4j服务器的负担

|缓存方式 | 快速 | 可监控 | 实现简单 | 内存使用量可控 | 扩容方便 | 生命周期管理 | 不加重Neo4j服务器负担 | 典型工具 |
| :---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|ConcurrentHashMap | 最快 | 需自行实现 | 代码量取决于需求 | 不可控 | 不方便,JVM的堆大小被固定 | 无,若自行实现，则不如直接使用三方jar | 加重，影响GC | |
| 堆上缓存 | 仅慢于 ConcurrentHashMap | 可监控 | 实现简单 | 可控 | 不方便,JVM的堆大小被固定 | 有 | 加重，影响GC | Ehcache,Guava Cache|
| 堆外缓存| 慢于堆上缓存 | 可监控 | 实现简单 | 可控 | 不方便,受限于机器的物理内存 | 有 | 不加重GC负担 | Ehcache |
| 缓存服务器 | 更慢了 | 可监控 | 实现简单 | 可控 | 方便 | 有 | 不加重GC负担,但会消耗大量带宽,降低Neo4j的吞吐量 | Redis,Memcached|

鉴于Neo4j作为图数据库，也没啥好的图分割方案，故而不会用到分布式缓存; 把Neo4j的内存割一部分给应用缓存也可以被接受。又为了在单机上支持一个超大的图，Neo4j的内存可能会设置得很大，JVM管理的内存本身就很多了，即便使用`G1 GC`,我们也不用在JVM管理我们的缓存数据了,虽然对于访问频率超高的数据可以放在堆里，但更多数据还是放堆外缓存好了。

扯了这么多，以上算是奶一波Ehcache3.

## 对null值的处理

DDoS的一种攻击方式是，使用不存在的key发出大量请求,此时得到的应该时一个无意义的值，比如null,空的List/Set/Map等。不管是何种存储结构，查找某个不存在的key,都比查找某个存在的key更消耗资源。如果没有使用索引，或者即便使用了合理的索引之后，资源消耗还是特点厉害。这种方式是很容易拖垮应用的。

缓存设计时需要考虑抵御DDoS，即若在数据库中查找某个key,计算出的结果无意义也将其缓存起来。从而减轻数据库的负载。不过该方式需要和合理的过期策略/主动更新策略结合使用才行。

以下是个人觉得不合适的使用方式

```java
// 由于有过期策略和剔除策略的影响,以下代码不是线程安全的
// 如果条件成立，即缓存中存在某个key
// 在未执行cache.get(key)之前，其他线程序可能将该key删除
// 那么 执行cache.get(key)得到的就是null值
// 按照业务逻辑，此时应该读取数据库，重新计算
// 但以下的代码是做不到的
if (!cache.containsKey(key)){
    logger.debug("key " + key + "miss!");
    // 缓存不命中，则需要重新计算，并写缓存
    String value = service.doTask(databaseService,key);
    // 即使结果为null, 也缓存起来; 以防止DDoS攻击
    cache.put(key,value);
    return value;
}else {
    return cache.get(key);
}

```

## 使用
